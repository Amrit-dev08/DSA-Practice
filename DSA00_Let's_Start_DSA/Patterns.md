# ðŸš€ DSA Roadmap: Pattern-wise Guide

This roadmap is structured around **patterns** instead of individual problems, helping you recognize recurring techniques across problems. Mastering these patterns will make problem-solving more efficient and systematic.

---

## 1. Arrays & Searching Patterns

* **Two Pointers**

  * LC #167. Two Sum II â€“ Input Array is Sorted
  * LC #15. 3Sum
  * LC #42. Trapping Rain Water
* **Sliding Window**

  * LC #3. Longest Substring Without Repeating Characters
  * LC #76. Minimum Window Substring
  * LC #209. Minimum Size Subarray Sum
* **Prefix Sum**

  * LC #560. Subarray Sum Equals K
  * LC #238. Product of Array Except Self
  * LC #325. Maximum Size Subarray Sum Equals k
* **Binary Search + Variants**

  * LC #33. Search in Rotated Sorted Array
  * LC #81. Search in Rotated Sorted Array II
  * LC #704. Binary Search
* **Merge Intervals**

  * LC #56. Merge Intervals
  * LC #57. Insert Interval
* **Cyclic Sort**

  * LC #41. First Missing Positive
  * LC #442. Find All Duplicates in an Array
* **Dutch National Flag (3-way Partitioning)**

  * LC #75. Sort Colors
* **Meet in the Middle**

  * LC #872. Leaf-Similar Trees
  * LC #805. Split Array With Same Average
* **Kadaneâ€™s Variants**

  * LC #53. Maximum Subarray
  * LC #918. Maximum Sum Circular Subarray
* **Reservoir Sampling**

  * LC #382. Linked List Random Node
* **Moâ€™s Algorithm** *(Advanced)*

  * CF Problems like 86C (D-query)

---

## 2. Linked List Patterns

* **Fast & Slow Pointers**

  * LC #141. Linked List Cycle
  * LC #142. Linked List Cycle II
  * LC #876. Middle of the Linked List
* **In-place Reverse Linked List**

  * LC #206. Reverse Linked List
  * LC #92. Reverse Linked List II
* **Flatten Linked List**

  * LC #430. Flatten a Multilevel Doubly Linked List
* **Copy List with Random Pointer**

  * LC #138. Copy List with Random Pointer
* **Skip List** *(Optional, Advanced)*

  * LC #1206. Design Skiplist

---

## 3. Stack, Queue & Greedy Patterns

* **Monotonic Stack**

  * LC #84. Largest Rectangle in Histogram
  * LC #739. Daily Temperatures
* **Stack Simulation**

  * LC #155. Min Stack
  * LC #20. Valid Parentheses
* **Deque-based Sliding Window**

  * LC #239. Sliding Window Maximum
* **Priority Queue / Heap Patterns**

  * LC #295. Find Median from Data Stream
* **Histogram Problems**

  * LC #85. Maximal Rectangle
* **Interval Scheduling (Greedy)**

  * LC #435. Non-overlapping Intervals
* **Gas Station / Jump Game Variants**

  * LC #55. Jump Game
  * LC #134. Gas Station
* **Core Greedy Algorithms**

  * LC #621. Task Scheduler

---

## 4. Tree Patterns

* **Binary Tree DFS**

  * LC #104. Maximum Depth of Binary Tree
  * LC #112. Path Sum
* **Binary Tree BFS**

  * LC #102. Binary Tree Level Order Traversal
  * LC #107. Binary Tree Level Order Traversal II
* **Binary Search Tree**

  * LC #230. Kth Smallest Element in a BST
  * LC #98. Validate BST
* **Segment Tree / Fenwick Tree (BIT)**

  * LC #307. Range Sum Query - Mutable
  * LC #327. Count of Range Sum
* **Lowest Common Ancestor (LCA)**

  * LC #236. Lowest Common Ancestor of a Binary Tree
  * LC #1650. Lowest Common Ancestor of a Binary Tree III
* **Binary Tree Diameter**

  * LC #543. Diameter of Binary Tree
* **Binary Lifting for Trees**

  * CF/CP implementations

---

## 5. Graph Patterns

* **BFS & DFS Traversals**

  * LC #200. Number of Islands
  * LC #785. Is Graph Bipartite?
* **Topological Sort**

  * LC #210. Course Schedule II
* **Union-Find (Disjoint Set Union - DSU)**

  * LC #684. Redundant Connection
* **Shortest Path Algorithms**

  * LC #787. Cheapest Flights Within K Stops
  * LC #743. Network Delay Time
* **Minimum Spanning Tree (Primâ€™s, Kruskalâ€™s)**

  * LC #1135. Connecting Cities With Minimum Cost
* **Strongly Connected Components**

  * LC #1192. Critical Connections in a Network
* **Bipartite Graph Check**

  * LC #886. Possible Bipartition
* **Bridges & Articulation Points**

  * LC #1192. Critical Connections in a Network
* **Flow Algorithms**

  * LC #329. Longest Increasing Path in a Matrix (conceptual application)
* **Eulerian / Hamiltonian Paths** *(Optional)*

  * LC #332. Reconstruct Itinerary

---

## 6. Backtracking & Combinatorics

* **Subsets**

  * LC #78. Subsets
  * LC #90. Subsets II
* **Permutations**

  * LC #46. Permutations
  * LC #47. Permutations II
* **Palindrome Partitioning**

  * LC #131. Palindrome Partitioning
* **N-Queens, Sudoku Solver, Word Search**

  * LC #51. N-Queens
  * LC #37. Sudoku Solver
  * LC #79. Word Search
* **Bitmasking in Subsets/Permutations**

  * LC #526. Beautiful Arrangement
* **Gray Code Generation**

  * LC #89. Gray Code
* **Combination Sum Variants**

  * LC #39. Combination Sum
  * LC #40. Combination Sum II
* **Constraint-Satisfaction Problems (CSP)**

  * LC #465. Optimal Account Balancing

---

## 7. Dynamic Programming (DP) Patterns

* **1D DP**

  * LC #70. Climbing Stairs
  * LC #198. House Robber
* **2D DP**

  * LC #1143. Longest Common Subsequence
  * LC #72. Edit Distance
* **Kadaneâ€™s Algorithm**

  * LC #53. Maximum Subarray
* **State Machine DP**

  * LC #309. Best Time to Buy and Sell Stock with Cooldown
* **Interval DP**

  * LC #312. Burst Balloons
* **Bitmask DP**

  * LC #473. Matchsticks to Square
* **DP on Trees**

  * LC #337. House Robber III
* **DP on Graphs**

  * LC #787. Cheapest Flights Within K Stops
* **Digit DP**

  * LC #902. Numbers At Most N Given Digit Set
* **Divide & Conquer DP**

  * LC #312. Burst Balloons
* **Game Theory DP**

  * LC #294. Flip Game II
* **Memory Optimization in DP**

  * LC #198. House Robber (optimized)

---

## 8. Advanced Data Structures & Patterns

* **Tries**

  * LC #208. Implement Trie
  * LC #212. Word Search II
* **Bit Manipulation Patterns**

  * LC #136. Single Number
  * LC #260. Single Number III
* **String Matching**

  * LC #28. Implement strStr()
  * LC #459. Repeated Substring Pattern
* **Suffix Array / Suffix Tree**

  * LC #943. Find the Shortest Superstring
* **Rolling Hash**

  * LC #187. Repeated DNA Sequences
* **Treaps / Splay Trees**

  * LC #708. Insert into a Cyclic Sorted List (conceptual)
* **Heavy-Light Decomposition (HLD)**

  * CF Implementation Problems
* **Persistent Segment Tree**

  * CF Implementation Problems
* **Wavelet Tree** *(Advanced CP)*

  * CF Implementation Problems
* **Bloom Filter**

  * Conceptual Applications
* **Disjoint Sparse Table (RMQ in O(1))**

  * CP Implementation Problems
* **Geometry Algorithms** *(Optional for Competitive Programming)*

  * LC #812. Largest Triangle Area

---

## 9. Number Theory & Math

* **Modular Arithmetic & Fast Exponentiation**

  * LC #50. Pow(x, n)
* **Extended Euclidean Algorithm & Modular Inverse**

  * Conceptual
* **Chinese Remainder Theorem (CRT)**

  * CP Problems
* **Sieve of Eratosthenes + Segmented Sieve**

  * LC #204. Count Primes
* **Prime Factorization**

  * LC #326. Power of Three (conceptual)
* **Matrix Exponentiation**

  * LC #509. Fibonacci Number
* **Combinatorics with Modulo**

  * LC #62. Unique Paths

---

## 10. Advanced Competitive Programming Topics

* **Meet-in-the-Middle**

  * LC #805. Split Array With Same Average
* **Square Root Decomposition (Range Queries)**

  * CF Problems like 86C (D-query)
* **Convex Hull (Graham Scan, Monotone Chain)**

  * CP Geometry Problems
* **Line Sweep Algorithms**

  * LC #986. Interval List Intersections
* **Bitset Optimization**

  * LC #526. Beautiful Arrangement
* **Offline Query Processing**

  * CF Implementation Problems

---

## ðŸ“Œ How to Use This Roadmap

1. **Pick one category at a time.** Donâ€™t jump randomly.
2. **Understand the pattern first** (dry run examples).
3. **Solve 4â€“5 problems per pattern** to solidify.
4. **Gradually mix patterns** in practice contests.

---

## ðŸ“š Recommended Resources

* *LeetCode Explore & Problem Lists*
* *Codeforces & AtCoder Problem Sets*
* *CP-Algorithms (cp-algorithms.com)*
* *NeetCode 150 & Striverâ€™s A2Z DSA Sheet*

---

ðŸ”¥ Stay consistent, track your progress, and master patterns instead of isolated problems. This will prepare you for **interviews, coding rounds, and competitive programming.**